<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Pixel Mix</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>

<style>
  body {
    margin: 0;
    font-family: system-ui, sans-serif;
    background: #111;
    color: #fff;
    text-align: center;
  }

  h1 { margin: 10px 0; }

  canvas {
    border: 4px solid #fff;
    border-radius: 8px;
    image-rendering: pixelated;
  }

  .row {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin: 12px 0;
  }

  button {
    padding: 14px;
    font-size: 16px;
    border-radius: 10px;
    border: none;
    width: 120px;
  }

  .result {
    margin-top: 10px;
    font-size: 18px;
  }
</style>
</head>
<body>

<h1>ðŸŽ¨ Pixel Mix</h1>
<div>Level <span id="level">1</span></div>

<div class="row">
  <canvas id="target" width="80" height="80"></canvas>
  <canvas id="mix" width="80" height="80"></canvas>
</div>

<div class="row">
  <button id="btnA">Hold</button>
  <button id="btnB">Hold</button>
</div>

<button onclick="submit()">Submit</button>

<div class="result" id="result"></div>

<script>
/* ---------------- CONFIG ---------------- */
const SIZE = 20;                 // grid width/height (pixels)
const PIXEL_SIZE = 4;            // visual scale
const POUR_RATE = 6;             // pixels per tick
const MIX_RATE = 120;            // random swaps per frame
const MAX_PIXELS = SIZE * SIZE;

/* ---------------- STATE ---------------- */
let level = 1;
let grid = [];
let targetColor = {};
let pouring = null;
let colors = [];

/* ---------------- CANVAS SETUP ---------------- */
const mixCanvas = document.getElementById("mix");
const targetCanvas = document.getElementById("target");

mixCanvas.width = targetCanvas.width = SIZE;
mixCanvas.height = targetCanvas.height = SIZE;

mixCanvas.style.width = targetCanvas.style.width = SIZE * PIXEL_SIZE + "px";
mixCanvas.style.height = targetCanvas.style.height = SIZE * PIXEL_SIZE + "px";

const mixCtx = mixCanvas.getContext("2d");
const targetCtx = targetCanvas.getContext("2d");

/* ---------------- UTIL ---------------- */
const randColor = () => ({
  r: Math.random() * 255,
  g: Math.random() * 255,
  b: Math.random() * 255
});

const colorStr = c => `rgb(${c.r|0},${c.g|0},${c.b|0})`;

function avgColor() {
  let r = 0, g = 0, b = 0;
  grid.forEach(p => {
    r += p.r;
    g += p.g;
    b += p.b;
  });
  return {
    r: r / grid.length,
    g: g / grid.length,
    b: b / grid.length
  };
}

function diff(a, b) {
  return Math.abs(a.r - b.r) +
         Math.abs(a.g - b.g) +
         Math.abs(a.b - b.b);
}

/* ---------------- LEVEL SETUP ---------------- */
function startLevel() {
  document.getElementById("level").textContent = level;
  document.getElementById("result").textContent = "";

  grid = [];
  targetColor = randColor();

  colors = [randColor(), randColor()];
  if (level > 25) colors.push(randColor());

  drawTarget();

  document.getElementById("btnA").style.background = colorStr(colors[0]);
  document.getElementById("btnB").style.background = colorStr(colors[1]);

  render();
}

/* ---------------- DRAWING ---------------- */
function drawTarget() {
  targetCtx.fillStyle = colorStr(targetColor);
  targetCtx.fillRect(0, 0, SIZE, SIZE);
}

function render() {
  mixCtx.clearRect(0, 0, SIZE, SIZE);
  grid.forEach(p => {
    mixCtx.fillStyle = colorStr(p);
    mixCtx.fillRect(p.x, p.y, 1, 1);
  });
}

/* ---------------- POURING ---------------- */
function pour(color) {
  for (let i = 0; i < POUR_RATE; i++) {
    if (grid.length >= MAX_PIXELS) return;

    grid.push({
      x: grid.length % SIZE,
      y: Math.floor(grid.length / SIZE),
      r: color.r,
      g: color.g,
      b: color.b
    });
  }
}

/* ---------------- MIXING (PIXEL DIFFUSION) ---------------- */
function mixPixels() {
  for (let i = 0; i < MIX_RATE; i++) {
    if (grid.length < 2) return;
    const a = Math.floor(Math.random() * grid.length);
    const b = Math.floor(Math.random() * grid.length);
    [grid[a].x, grid[b].x] = [grid[b].x, grid[a].x];
    [grid[a].y, grid[b].y] = [grid[b].y, grid[a].y];
  }
}

/* ---------------- GAME LOOP ---------------- */
function loop() {
  mixPixels();
  render();
  requestAnimationFrame(loop);
}

/* ---------------- SUBMIT ---------------- */
function submit() {
  if (grid.length < MAX_PIXELS * 0.7) {
    document.getElementById("result").textContent = "Fill more!";
    return;
  }

  const mixed = avgColor();
  const tolerance = Math.max(70 - level, 30);

  if (diff(mixed, targetColor) < tolerance) {
    document.getElementById("result").textContent = "âœ” Level Complete";
    level++;
    setTimeout(startLevel, 900);
  } else {
    document.getElementById("result").textContent = "âœ– Off Color";
  }
}

/* ---------------- INPUT ---------------- */
["btnA", "btnB"].forEach((id, idx) => {
  const btn = document.getElementById(id);

  btn.addEventListener("pointerdown", () => {
    pouring = setInterval(() => pour(colors[idx]), 50);
  });

  btn.addEventListener("pointerup", () => clearInterval(pouring));
  btn.addEventListener("pointerleave", () => clearInterval(pouring));
});

/* ---------------- START ---------------- */
startLevel();
loop();
</script>

</body>
</html>
